# Min Heap
# bids and asks
# with price, amount and trader encoded in a single 256 bit value

data heap[2*256]


def push(item):

    length = self.heap[0]
    k = length + 1
    self.heap[k] = item
    log(k)
    while k > 1:
        bottom = self.heap[k]
        top = self.heap[k/2]
        if bottom < top:
            self.heap[k] = top
            self.heap[k/2] = bottom
            k /= 2
        else:
            k = 0
    self.heap[0] = k


def pop():
    length = self.heap[0]
    if !length:
        return(0)
    prevtop = self.heap[1]
    self.heap[1] = self.heap[length]
    self.heap[length] = 0
    top = self.heap[1]
    k = 1
    while k * 2 < length:
        bottom1 = self.heap[k * 2]
        bottom2 = self.heap[k * 2 + 1]
        if bottom1 < top and (bottom1 < bottom2 or k * 2 + 1 >= length):
            self.heap[k] = bottom1
            self.heap[k * 2] = top
            k = k * 2
        elif bottom2 < top and bottom2 < bottom1 and k * 2 + 1 < length:
            self.heap[k] = bottom2
            self.heap[k * 2 + 1] = top
            k = k * 2 + 1
        else:
            k = length
    self.heap[0] = length - 1
    return(prevtop)


def top():
    return(self.heap[1])


def length():
    return(self.heap[0])
